from fastapi import APIRouter, HTTPException, status, Depends
from typing import List
from app.models import Task, TaskCreate, CodeChange, ChangeModification, User
from app.auth import get_current_user
from app.database import get_supabase
import uuid

router = APIRouter()


@router.post("/tasks", response_model=Task)
async def submit_task(
    project_id: str,
    task_data: TaskCreate,
    current_user: User = Depends(get_current_user)
):
    """Submit a task to an agent"""
    supabase = get_supabase()
    
    # Verify project access
    project_response = supabase.table("projects")\
        .select("user_id")\
        .eq("id", project_id)\
        .execute()
    
    if not project_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    if project_response.data[0]["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Create task
    import uuid
    task_id = str(uuid.uuid4())
    task_data_dict = {
        "id": task_id,
        "project_id": project_id,
        "agent_type": task_data.agent_type,
        "description": task_data.description,
        "status": "pending",
        "input_context": {"user_request": task_data.description},
    }
    
    task_response = supabase.table("tasks").insert(task_data_dict).execute()
    
    # Simulate agent processing (in production, this would be async)
    await process_agent_task(task_id, task_data.agent_type, task_data.description)
    
    return Task(**task_response.data[0])


async def process_agent_task(task_id: str, agent_type: str, description: str):
    """Process a task with the appropriate agent"""
    supabase = get_supabase()
    
    # Simulate agent work and create a code change
    import uuid
    change_id = str(uuid.uuid4())
    
    # Generate mock code change based on agent type
    if agent_type == "design":
        file_path = "components/NewComponent.js"
        diff = f"""+ import React from 'react';
+ import {{ View, Text, StyleSheet }} from 'react-native';
+ 
+ export default function NewComponent() {{
+   return (
+     <View style={{styles.container}}>
+       <Text>Generated by Design Agent: {description}</Text>
+     </View>
+   );
+ }}
+ 
+ const styles = StyleSheet.create({{
+   container: {{
+     padding: 16,
+   }},
+ }});"""
        reasoning = f"Created new UI component based on request: {description}"
    
    elif agent_type == "backend":
        file_path = "services/api.js"
        diff = f"""+ // Generated by Backend Agent
+ export const newApiEndpoint = async () => {{
+   // Implementation for: {description}
+   return fetch('/api/new-endpoint');
+ }};"""
        reasoning = f"Added new API functionality: {description}"
    
    else:  # testing
        file_path = "__tests__/NewComponent.test.js"
        diff = f"""+ import React from 'react';
+ import {{ render }} from '@testing-library/react-native';
+ import NewComponent from '../components/NewComponent';
+ 
+ describe('NewComponent', () => {{
+   it('renders correctly', () => {{
+     // Test for: {description}
+     const {{ getByText }} = render(<NewComponent />);
+     expect(getByText).toBeDefined();
+   }});
+ }});"""
        reasoning = f"Added tests for: {description}"
    
    # Create code change
    change_data = {
        "id": change_id,
        "task_id": task_id,
        "file_path": file_path,
        "change_type": "create",
        "diff": diff,
        "agent_type": agent_type,
        "reasoning": reasoning,
        "approved": None,  # Pending approval
    }
    
    supabase.table("code_changes").insert(change_data).execute()
    
    # Update task status
    supabase.table("tasks")\
        .update({
            "status": "completed",
            "output": {"generated_files": [file_path]},
            "completed_at": "now()"
        })\
        .eq("id", task_id)\
        .execute()


@router.get("/changes/pending", response_model=List[CodeChange])
async def get_pending_changes(
    project_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get pending code changes"""
    supabase = get_supabase()
    
    # Verify project access
    project_response = supabase.table("projects")\
        .select("user_id")\
        .eq("id", project_id)\
        .execute()
    
    if not project_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    if project_response.data[0]["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Get pending changes (approved = null means pending)
    changes_response = supabase.table("code_changes")\
        .select("*, tasks!inner(project_id)")\
        .eq("tasks.project_id", project_id)\
        .is_("approved", "null")\
        .order("created_at", desc=True)\
        .execute()
    
    return [CodeChange(**change) for change in changes_response.data]


@router.post("/changes/{change_id}/approve")
async def approve_change(
    project_id: str,
    change_id: str,
    current_user: User = Depends(get_current_user)
):
    """Approve a code change"""
    supabase = get_supabase()
    
    # Verify change exists and belongs to user's project
    change_response = supabase.table("code_changes")\
        .select("*, tasks!inner(project_id, projects!inner(user_id))")\
        .eq("id", change_id)\
        .eq("tasks.project_id", project_id)\
        .execute()
    
    if not change_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Code change not found"
        )
    
    change = change_response.data[0]
    if change["tasks"]["projects"]["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Update change as approved
    supabase.table("code_changes")\
        .update({"approved": True})\
        .eq("id", change_id)\
        .execute()
    
    # TODO: Apply the change to the actual codebase/sandbox
    
    return {"message": "Change approved successfully"}


@router.post("/changes/{change_id}/reject")
async def reject_change(
    project_id: str,
    change_id: str,
    current_user: User = Depends(get_current_user)
):
    """Reject a code change"""
    supabase = get_supabase()
    
    # Verify change exists and belongs to user's project
    change_response = supabase.table("code_changes")\
        .select("*, tasks!inner(project_id, projects!inner(user_id))")\
        .eq("id", change_id)\
        .eq("tasks.project_id", project_id)\
        .execute()
    
    if not change_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Code change not found"
        )
    
    change = change_response.data[0]
    if change["tasks"]["projects"]["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Update change as rejected
    supabase.table("code_changes")\
        .update({"approved": False})\
        .eq("id", change_id)\
        .execute()
    
    return {"message": "Change rejected successfully"}


@router.post("/changes/{change_id}/modify")
async def request_modification(
    project_id: str,
    change_id: str,
    modification: ChangeModification,
    current_user: User = Depends(get_current_user)
):
    """Request modification to a code change"""
    supabase = get_supabase()
    
    # Verify change exists and belongs to user's project
    change_response = supabase.table("code_changes")\
        .select("*, tasks!inner(project_id, projects!inner(user_id))")\
        .eq("id", change_id)\
        .eq("tasks.project_id", project_id)\
        .execute()
    
    if not change_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Code change not found"
        )
    
    change = change_response.data[0]
    if change["tasks"]["projects"]["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Create new task for modification
    task_id = str(uuid.uuid4())
    task_data = {
        "id": task_id,
        "project_id": project_id,
        "agent_type": change["agent_type"],
        "description": f"Modify previous change: {modification.feedback}",
        "status": "pending",
        "input_context": {
            "modification_request": modification.feedback,
            "original_change_id": change_id,
            "original_file": change["file_path"]
        },
    }
    
    supabase.table("tasks").insert(task_data).execute()
    
    # Mark original change as rejected
    supabase.table("code_changes")\
        .update({"approved": False})\
        .eq("id", change_id)\
        .execute()
    
    # Process the modification request
    await process_modification_request(task_id, change, modification.feedback)
    
    return {"message": "Modification request submitted successfully"}


@router.get("/sandbox")
async def get_sandbox(
    project_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get sandbox information"""
    # TODO: Implement sandbox info retrieval
    raise HTTPException(status_code=501, detail="Not implemented yet")


@router.get("/preview")
async def get_preview(
    project_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get preview information"""
    supabase = get_supabase()
    
    # Verify project access
    project_response = supabase.table("projects")\
        .select("user_id, status")\
        .eq("id", project_id)\
        .execute()
    
    if not project_response.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    project = project_response.data[0]
    if project["user_id"] != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )
    
    # Check if there are any approved changes (indicates app is ready)
    approved_changes = supabase.table("code_changes")\
        .select("id", count="exact")\
        .eq("tasks.project_id", project_id)\
        .eq("approved", True)\
        .execute()
    
    has_approved_changes = approved_changes.count > 0 if approved_changes.count else False
    
    if has_approved_changes or project["status"] == "ready":
        # Mock preview data - in production this would come from E2B
        return {
            "status": "ready",
            "preview_url": f"https://expo.dev/@preview/{project_id}",
            "qr_code": f"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="
        }
    else:
        return {
            "status": "building",
            "preview_url": None,
            "qr_code": None
        }


async def process_modification_request(task_id: str, original_change: dict, feedback: str):
    """Process a modification request and create a new code change"""
    supabase = get_supabase()
    
    # Generate modified code based on feedback
    change_id = str(uuid.uuid4())
    
    # Create a modified version of the original change
    modified_diff = f"""# Modified based on feedback: {feedback}
{original_change['diff']}
+ // Additional modifications based on user feedback
+ // {feedback}"""
    
    change_data = {
        "id": change_id,
        "task_id": task_id,
        "file_path": original_change["file_path"],
        "change_type": "modify",
        "diff": modified_diff,
        "agent_type": original_change["agent_type"],
        "reasoning": f"Modified based on user feedback: {feedback}",
        "approved": None,  # Pending approval
    }
    
    supabase.table("code_changes").insert(change_data).execute()
    
    # Update task status
    supabase.table("tasks")\
        .update({
            "status": "completed",
            "output": {"modification_applied": True, "feedback": feedback},
            "completed_at": "now()"
        })\
        .eq("id", task_id)\
        .execute()
